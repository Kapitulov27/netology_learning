# Shell vs Exec форма

## Синтаксис

```dockerfile
ENTRYPOINT ["python", "app.py"]   # exec  - напрямую, PID 1 = python
ENTRYPOINT python app.py          # shell - через /bin/sh -c, PID 1 = sh

CMD ["python", "app.py"]          # exec  - напрямую
CMD python app.py                 # shell - через /bin/sh -c
```

## Сравнение

|              | Exec-массив          | Shell-форма         |
|--------------|----------------------|---------------------|
| PID 1        | само приложение      | /bin/sh             |
| SIGTERM      | доходит напрямую ✓   | может поглотиться ⚠ |
| $VAR         | не интерполируются ⚠ | интерполируются ✓   |

---

## Не смешивайте формы в ENTRYPOINT + CMD

### ❌ ENTRYPOINT exec + CMD shell:

```dockerfile
ENTRYPOINT ["python", "app.py"]
CMD --verbose
```

Python запускается как PID 1 и получит аргументы: `/bin/sh`, `-c`, `--verbose` (а не просто `--verbose`)

### ❌ ENTRYPOINT shell + CMD exec:

```dockerfile
ENTRYPOINT python app.py
CMD ["--verbose"]
```

Выполнится: `/bin/sh -c "python app.py"` и CMD игнорируется

### ✓ Правильно (обе exec):

```dockerfile
ENTRYPOINT ["python", "app.py"]
CMD ["--verbose"]
```

Выполнится: `python app.py --verbose`

### ✓ А еще лучше:

```dockerfile
CMD ["python", "app.py", "--verbose"]
```

Выполнится: `python app.py --verbose`

---

## ЛАЙФХАК: Shell-exec компромисс

```dockerfile
CMD exec python app.py --verbose
```

**Что происходит:** Docker выполняет `/bin/sh -c "exec python app.py --verbose"`

- ✅ PID 1 изначально = `/bin/sh`, но `exec` заменяет оболочку на `python`
- ✅ В итоге PID 1 = `python`, сигналы обрабатываются корректно
- ✅ Переменные окружения `$VAR` интерполируются
- ✅ Можно использовать `&&`, `||`, `;`, подстановки и пайпы

**⚠️ Проблема:** Shell зависит от базового образа
- Alpine → `/bin/ash`
- Debian/Ubuntu → `bash`
- BusyBox → `dash`

Поведение может различаться между окружениями (кавычки, пайпы, интерполяция переменных)

---

## Зачем нужна shell форма?

### 1. Выполнение нескольких команд

```dockerfile
CMD apt-get update && apt-get install -y curl && curl -s http://example.com
```

❌ Exec форма не сработает:
```dockerfile
CMD ["apt-get", "update", "&&", "apt-get", "install", "curl"]
```

### 2. Подстановка команд

```dockerfile
CMD echo "Container started at $(date)"
```

Exec форма не парсит `$()`

### 3. Инициализационный скрипт

```dockerfile
ENTRYPOINT bash -c "/entrypoint.sh"
```

```bash
#!/bin/bash
set -e
start_postgres &
start_redis &
exec app
```

Shell обеспечивает параллельный запуск и контроль процессов

### 4. Переменные окружения

```dockerfile
export NAME=world
CMD ["echo", "$NAME"]       # Выведет: $NAME (не интерполируется!)
CMD echo $NAME              # Выведет: world (интерполируется)
CMD exec echo $NAME         # Выведет: world (интерполируется)
```

---

## Итоговое сравнение

### Exec форма: `CMD ["python", "app.py", "--verbose"]`

**Что делает Docker/k8s:**
```
python app.py --verbose  # Напрямую, без /bin/sh
```

- ✅ PID 1 = python
- ✅ Сигналы и завершение работают идеально
- ✅ Канонически правильная форма для production
- ❌ Нельзя использовать `&&`, `;`, `$VAR`, `~`

### Shell-exec форма: `CMD exec python app.py --verbose`

**Что делает Docker/k8s:**
```
/bin/sh -c "exec python app.py --verbose"
```

- ✅ PID 1 в итоге = python (благодаря exec)
- ✅ Сигналы работают корректно
- ✅ Доступны shell-фичи (`&&`, `$VAR`, etc)
- ⚠️ Зависит от shell в базовом образе
- ⚠️ Нарушает принцип явности

---

## Вывод

**Exec форма** — каноничная, чистая, безопасная, рекомендуемая для production

**Shell-exec форма** — компромисс для инженеров, когда нужны shell-фичи, но может вызывать неочевидные ошибки